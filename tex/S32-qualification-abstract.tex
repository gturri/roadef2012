\documentclass[a4paper,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage[margin=2cm]{geometry}

\title{Qualification~abstract of team~S32:
  An~exact~metaheuristic}

\author{Pierre-Etienne Bougué \and Florian Colin \and Denis Daste
  \and Kamal Fadlaoui \and Quentin Lequy \and Guillaume Pinot \and
  Cédric Royer \and Guillaume Turri}

\begin{document}

\maketitle

\section{Introduction}

We developped a new metaheuristic to solve the problem of the
ROADEF/EURO challenge.  This method is an hybridation
of a Branch and Bound with a GRASP using Monte Carlo Tree Search.

First, we present the method and its different parts.  Then, we show
the results obtained on the given instances.  Finally, we expose an overview of
the improvements we intend doing to the method.

\section{Method}

\subsection{Monte Carlo Tree Search}

Kocsis and Szepesv\'ari\cite{kocsis2006bandit} proposed to guide the exploration of a tree
using multi-armed bandit technics and Monte Carlo to evaluate
a node.  This method is also known as UCT (for Upper Confidence bound
for Tree, the name of the main formula of the method) or MCTS (for
Monte Carlo Tree Search).  Thanks to this method, Mogo, an
artificial intelligence for Go game, became competitive with humans
\cite{gelly2007contribution}.  Because this method allows to explore a
tree integrating the exploration-exploitation problem, we decided to
base our optimization method on MCTS.

The method works as follow:
\begin{itemize}
\item UCT chooses a node to expand.
\item The node is expanded, and a Monte Carlo simulation is done for
  each newly created node. Each Monte Carlo simulation returns an
  evaluation of its node between 0 and 1.
\item The evaluation is used to update the
  knowledge of the problem.
\end{itemize}
This sequence is repeated until the stop condition is met.


We adapted MCTS to optimization problems. Our main modification is
the management of solved nodes.  As a consequence, if our method runs
long enough, it will stop with the optimal solution.

This method is composed of two main modules:
\begin{itemize}
\item a Search Tree;
\item a Monte Carlo Simulation system.
\end{itemize}

\subsection{Search Tree}

We use a simple branching scheme: we select the processus with the
most possible machine assignable, and we cut this list in two equal
parts.

\subsection{Monte Carlo Simulation}

The simulation is the core of the method.  According to
Gelly\cite{gelly2007contribution}, a good simulation must be random, and
improving the simulation with heuristics improves the results a lot.
That is why we chose to first randomly generate a solution, and
then improve it with a local search.

Because generating a purely random feasible solution is very
difficult, we search randomly a feasible solution near the
initial solution given.

On the feasible solution provided by the Monte Carlo method, we launch
a greedy algorithm to improve the solution.  The algorithm tries to move
every processus (ordered by importance) to every possible machine and
select the move if it improves the current solution.

\subsection{Technical details}

Our program uses C++ with the STL and the Boost library.  We also use
the autotools to build the project and Git to manage the sources.

To manage the constraints, we use Gecode, a C++ constraint programming
library under the MIT license.  Particularly, the Monte Carlo is done
using Gecode search procedures, and the local search uses Gecode
filtering.

Finally, our code is licenced under the ISC license, a well known BSD
style license.  So, our program and its dependencies are under BSD
style licences.

\section{Results}

The results of our method on the given instances are represented on
tab~\ref{tab:results}.

\begin{table}
  \centering
  \label{tab:results}
  \caption{Results of version c532113 on a 1.6GHz Intel Atom processor
    after 5\,min}
  \begin{tabular}{|c|r|r|}
    \hline
    instance & initial solution & solution\\
    \hline
    a1\_1 &   49528750 &   44306501\\
    a1\_2 & 1061649570 &  911336551\\
    a1\_3 &  583662270 &  583379455\\
    a1\_4 &  632499600 &  375837838\\
    a1\_5 &  782189690 &  737698361\\
    a2\_1 &  391189190 &   27096127\\
    a2\_2 & 1876768120 & 1376369463\\
    a2\_3 & 2272487840 & 1774597843\\
    a2\_4 & 3223516130 & 2247406998\\
    a2\_5 &  787355300 &  741201684\\
    \hline
  \end{tabular}
\end{table}

\section{Perspectives}

We identified several ways to improve the results of our method :
\begin{itemize}
\item improving the Monte Carlo Simulation using a heuristic to assign
a process to a machine
\item improving the local search by testing multiple technics : tabu search, simulated annealing, LP.
\item increasing the speed of local search evaluations using an incremental evaluation.
\item improving of the tree search
\item using parallel search : we do not use parallel computing so far, but it is totally applicable to a tree search.
\item using a lower bound
\end{itemize}

\section{Conclusion}

In this article we presented a new metaheuristic and applied it to a
real world problem.  We improve the solution on every given
instances.  Moreover, we identified a lot of possibilities of
improvement for our MCTS method.

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
